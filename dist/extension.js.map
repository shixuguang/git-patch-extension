{"version":3,"file":"extension.js","mappings":"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","sources":["../external node-commonjs \"util\"","../external node-commonjs \"child_process\"","../external commonjs \"vscode\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap",".././src/extension.ts"],"sourcesContent":["module.exports = require(\"util\");","module.exports = require(\"child_process\");","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// extension.ts\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('Git Patch Extension is now active');\n\n    let disposable = vscode.commands.registerCommand('git-patch.applyPatch', async () => {\n        try {\n            // 1. Prompt user to select a patch file\n            const fileUris = await vscode.window.showOpenDialog({\n                canSelectFiles: true,\n                canSelectFolders: false,\n                canSelectMany: false,\n                filters: {\n                    'Patch Files': ['patch', 'diff']\n                },\n                title: 'Select Git Patch File'\n            });\n\n            if (!fileUris || fileUris.length === 0) {\n                return;\n            }\n\n            const patchFilePath = fileUris[0].fsPath;\n            const workspaceFolders = vscode.workspace.workspaceFolders;\n            \n            if (!workspaceFolders) {\n                vscode.window.showErrorMessage('No workspace folder is open');\n                return;\n            }\n\n            const workspaceRoot = workspaceFolders[0].uri.fsPath;\n            \n            // 2. Read the patch file\n            const patchContent = fs.readFileSync(patchFilePath, 'utf8');\n            \n            // 3. Parse the patch file to extract file changes\n            const fileChanges = parsePatchFile(patchContent);\n            \n            // 4. For each file change, show diff and prompt for confirmation\n            for (const change of fileChanges) {\n                const targetFilePath = path.join(workspaceRoot, change.filePath);\n                \n                // Handle different file types\n                if (change.fileType === 'directory') {\n                    vscode.window.showInformationMessage(`Skipping directory: ${change.filePath}`);\n                    continue;\n                }\n                \n                if (change.fileType === 'binary') {\n                    vscode.window.showInformationMessage(`Skipping binary file: ${change.filePath} (not supported in this version)`);\n                    continue;\n                }\n                \n                const targetFileExists = fs.existsSync(targetFilePath);\n                \n                // Handle deleted files\n                if (change.isDeleted) {\n                    if (targetFileExists) {\n                        const deleteFile = await vscode.window.showInformationMessage(\n                            `Delete file ${change.filePath}?`,\n                            'Yes', 'No'\n                        );\n                        \n                        if (deleteFile === 'Yes') {\n                            fs.unlinkSync(targetFilePath);\n                            vscode.window.showInformationMessage(`Deleted ${change.filePath}`);\n                        }\n                    }\n                    continue;\n                }\n                \n                // Create temporary file with the changes applied\n                const tempFilePath = path.join(workspaceRoot, `.temp_${path.basename(change.filePath)}`);\n                \n                // Skip if target is a directory\n                if (targetFileExists && fs.statSync(targetFilePath).isDirectory()) {\n                    vscode.window.showWarningMessage(`Skipping ${change.filePath} because it is a directory`);\n                    continue;\n                }\n                \n                let originalContent = '';\n                if (targetFileExists) {\n                    try {\n                        originalContent = fs.readFileSync(targetFilePath, 'utf8');\n                    } catch (error) {\n                        vscode.window.showErrorMessage(`Error reading ${change.filePath}: ${error instanceof Error ? error.message : String(error)}`);\n                        continue;\n                    }\n                }\n                \n                // Apply changes to create new content\n                const newContent = applyPatchToContent(originalContent, change);\n                \n                // Ensure temp directory exists\n                const tempDir = path.dirname(tempFilePath);\n                if (!fs.existsSync(tempDir)) {\n                    fs.mkdirSync(tempDir, { recursive: true });\n                }\n                \n                try {\n                    fs.writeFileSync(tempFilePath, newContent);\n                } catch (error) {\n                    vscode.window.showErrorMessage(`Error creating temp file for ${change.filePath}: ${error instanceof Error ? error.message : String(error)}`);\n                    continue;\n                }\n                \n                // 5. Show diff using VS Code's diff editor\n                const originalUri = targetFileExists \n                    ? vscode.Uri.file(targetFilePath)\n                    : vscode.Uri.file(tempFilePath).with({ scheme: 'untitled' });\n                const modifiedUri = vscode.Uri.file(tempFilePath);\n                \n                const title = `${change.filePath} (Git Patch Preview)`;\n                \n                try {\n                    await vscode.commands.executeCommand('vscode.diff', \n                        originalUri, \n                        modifiedUri,\n                        title\n                    );\n                } catch (error) {\n                    vscode.window.showErrorMessage(`Error showing diff for ${change.filePath}: ${error instanceof Error ? error.message : String(error)}`);\n                    continue;\n                }\n                \n                // 6. Prompt user to apply this change\n                const applyChange = await vscode.window.showInformationMessage(\n                    `Apply changes to ${change.filePath}?`,\n                    'Yes', 'No'\n                );\n                \n                if (applyChange === 'Yes') {\n                    try {\n                        // Create directory if it doesn't exist (for new files)\n                        const targetDir = path.dirname(targetFilePath);\n                        if (!fs.existsSync(targetDir)) {\n                            fs.mkdirSync(targetDir, { recursive: true });\n                        }\n                        \n                        // Apply changes\n                        fs.writeFileSync(targetFilePath, newContent);\n                        vscode.window.showInformationMessage(`Changes applied to ${change.filePath}`);\n                    } catch (error) {\n                        vscode.window.showErrorMessage(`Error applying changes to ${change.filePath}: ${error instanceof Error ? error.message : String(error)}`);\n                    }\n                }\n                \n                // Clean up temporary file\n                try {\n                    if (fs.existsSync(tempFilePath)) {\n                        fs.unlinkSync(tempFilePath);\n                    }\n                } catch (error) {\n                    console.log(`Error cleaning up temp file: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n        } catch (error) {\n            vscode.window.showErrorMessage(`Error applying patch: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n\n    context.subscriptions.push(disposable);\n\n    // Alternative approach using git command directly\n    let gitApplyDisposable = vscode.commands.registerCommand('git-patch.applyPatchWithGit', async () => {\n        try {\n            // 1. Prompt user to select a patch file\n            const fileUris = await vscode.window.showOpenDialog({\n                canSelectFiles: true,\n                canSelectFolders: false,\n                canSelectMany: false,\n                filters: {\n                    'Patch Files': ['patch', 'diff']\n                },\n                title: 'Select Git Patch File'\n            });\n\n            if (!fileUris || fileUris.length === 0) {\n                return;\n            }\n\n            const patchFilePath = fileUris[0].fsPath;\n            const workspaceFolders = vscode.workspace.workspaceFolders;\n            \n            if (!workspaceFolders) {\n                vscode.window.showErrorMessage('No workspace folder is open');\n                return;\n            }\n\n            const workspaceRoot = workspaceFolders[0].uri.fsPath;\n            \n            // 2. First show the changes without applying them (--check)\n            await execAsync(`git apply --check \"${patchFilePath}\"`, { cwd: workspaceRoot });\n            \n            // 3. Show what would be changed (--numstat)\n            const { stdout } = await execAsync(`git apply --numstat \"${patchFilePath}\"`, { cwd: workspaceRoot });\n            const changedFiles = stdout.split('\\n')\n                .filter(line => line.trim() !== '')\n                .map(line => {\n                    const parts = line.split('\\t');\n                    return parts[2];\n                });\n            \n            // 4. Ask for confirmation\n            const applyPatch = await vscode.window.showInformationMessage(\n                `Apply patch to ${changedFiles.length} file(s)?\\n${changedFiles.join(', ')}`,\n                'Yes', 'No'\n            );\n            \n            if (applyPatch !== 'Yes') {\n                return;\n            }\n            \n            // 5. Show diff for each file that would be changed\n            // First create a temporary index\n            const tempIndexFile = path.join(workspaceRoot, '.git', 'temp-index');\n            await execAsync(`git apply --cached --index=\"${tempIndexFile}\" \"${patchFilePath}\"`, { cwd: workspaceRoot });\n            \n            // For each file, show the diff using VS Code's diff editor\n            for (const filePath of changedFiles) {\n                const fullPath = path.join(workspaceRoot, filePath);\n                const { stdout: diffOutput } = await execAsync(\n                    `git diff --no-index -- \"${fullPath}\" \"${fullPath}\"`, \n                    { cwd: workspaceRoot, env: { ...process.env, GIT_INDEX_FILE: tempIndexFile } }\n                );\n                \n                // Create a temporary file with the patched content\n                const tempFilePath = path.join(workspaceRoot, `.temp_${path.basename(filePath)}`);\n                await execAsync(\n                    `git show \":${filePath}\" > \"${tempFilePath}\"`, \n                    { cwd: workspaceRoot, env: { ...process.env, GIT_INDEX_FILE: tempIndexFile } }\n                );\n                \n                // Show diff\n                await vscode.commands.executeCommand('vscode.diff',\n                    vscode.Uri.file(fullPath),\n                    vscode.Uri.file(tempFilePath),\n                    `${filePath} (Git Patch Preview)`\n                );\n                \n                // Clean up temp file\n                if (fs.existsSync(tempFilePath)) {\n                    fs.unlinkSync(tempFilePath);\n                }\n            }\n            \n            // 6. Apply the patch\n            await execAsync(`git apply \"${patchFilePath}\"`, { cwd: workspaceRoot });\n            vscode.window.showInformationMessage('Patch applied successfully');\n            \n        } catch (error) {\n            vscode.window.showErrorMessage(`Error applying patch: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n\n    context.subscriptions.push(gitApplyDisposable);\n}\n\n// Helper function to parse a patch file content\n// This is a simplified version - a real implementation would need to handle more edge cases\ninterface FileChange {\n    filePath: string;\n    fileType: 'file' | 'directory' | 'binary';\n    isNew: boolean;\n    isDeleted: boolean;\n    hunks: {\n        startLine: number;\n        lineCount: number;\n        content: string;\n    }[];\n}\n\nfunction parsePatchFile(patchContent: string): FileChange[] {\n    const fileChanges: FileChange[] = [];\n    // This is a simplified parser - a real implementation would be more robust\n    // Consider using libraries like parse-git-patch instead\n    \n    // For the example, we'll just do a basic parsing\n    const diffFiles = patchContent.split('diff --git');\n    \n    for (let i = 1; i < diffFiles.length; i++) {\n        const diffContent = diffFiles[i];\n        const lines = diffContent.split('\\n');\n        \n        // Extract file path\n        let filePathMatch = lines[0].match(/a\\/(.*) b\\/(.*)/);\n        \n        // Handle cases where paths might not use the standard a/ b/ format\n        if (!filePathMatch) {\n            // Try a different pattern\n            filePathMatch = lines[0].match(/\\\"(.*)\\\" \\\"(.*)\\\"/);\n            if (!filePathMatch) continue;\n        }\n        \n        const sourceFilePath = filePathMatch[1];\n        const targetFilePath = filePathMatch[2];\n        \n        // Use target path for general operations\n        const filePath = targetFilePath;\n        \n        // Determine file type and operation\n        let fileType: 'file' | 'directory' | 'binary' = 'file';\n        let isNew = false;\n        let isDeleted = false;\n        \n        // Check file headers for information\n        for (let j = 1; j < Math.min(lines.length, 10); j++) {\n            const line = lines[j];\n            \n            // Check for new file\n            if (line.includes('new file mode')) {\n                isNew = true;\n            }\n            \n            // Check for deleted file\n            if (line.includes('deleted file mode')) {\n                isDeleted = true;\n            }\n            \n            // Check for binary file\n            if (line.includes('Binary files')) {\n                fileType = 'binary';\n                break;\n            }\n            \n            // Check for directory\n            if (line.includes('old mode') && line.includes('new mode') && \n                (line.includes('040000') || line.includes('160000'))) {\n                fileType = 'directory';\n                break;\n            }\n        }\n        \n        // Skip directories for now since we're not handling them\n        if (fileType === 'directory') {\n            fileChanges.push({\n                filePath,\n                fileType,\n                isNew,\n                isDeleted,\n                hunks: []\n            });\n            continue;\n        }\n        \n        // Skip binary files for now\n        if (fileType === 'binary') {\n            fileChanges.push({\n                filePath,\n                fileType,\n                isNew,\n                isDeleted,\n                hunks: []\n            });\n            continue;\n        }\n        \n        const hunks: FileChange['hunks'] = [];\n        \n        // Find the hunks\n        let inHunk = false;\n        let currentHunk = { startLine: 0, lineCount: 0, content: '' };\n        let hunkHeaderMatch: RegExpMatchArray | null = null;\n        \n        for (let j = 1; j < lines.length; j++) {\n            const line = lines[j];\n            \n            if (line.startsWith('@@')) {\n                // Start of a new hunk\n                if (inHunk) {\n                    hunks.push({ ...currentHunk });\n                }\n                \n                // Support both formats:\n                // @@ -1,3 +1,4 @@ (showing line count)\n                // @@ -1 +1 @@ (single line, no comma)\n                hunkHeaderMatch = line.match(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n                if (hunkHeaderMatch) {\n                    inHunk = true;\n                    const startLine = parseInt(hunkHeaderMatch[3], 10);\n                    const lineCount = hunkHeaderMatch[4] ? parseInt(hunkHeaderMatch[4], 10) : 1;\n                    \n                    currentHunk = {\n                        startLine,\n                        lineCount,\n                        content: ''\n                    };\n                }\n            } else if (inHunk) {\n                // Add line to current hunk\n                currentHunk.content += line + '\\n';\n            }\n        }\n        \n        // Add the last hunk\n        if (inHunk) {\n            hunks.push({ ...currentHunk });\n        }\n        \n        fileChanges.push({ \n            filePath, \n            fileType, \n            isNew, \n            isDeleted, \n            hunks \n        });\n    }\n    \n    return fileChanges;\n}\n\n// Helper function to apply a patch to content\nfunction applyPatchToContent(originalContent: string, change: FileChange): string {\n    let lines = originalContent.split('\\n');\n    \n    // Apply hunks in reverse order (from bottom to top) to avoid line number shifts\n    const sortedHunks = [...change.hunks].sort((a, b) => b.startLine - a.startLine);\n    \n    for (const hunk of sortedHunks) {\n        const { startLine, content } = hunk;\n        \n        // Parse the hunk content to get actual changes\n        const hunkLines = content.split('\\n');\n        const newLines = hunkLines\n            .filter(line => !line.startsWith('-') && !line.startsWith('\\\\'))\n            .map(line => line.startsWith('+') ? line.substring(1) : line);\n        \n        // Replace lines in original content\n        const before = lines.slice(0, startLine - 1);\n        const after = lines.slice(startLine - 1 + hunkLines.filter(line => !line.startsWith('+')).length);\n        \n        lines = [...before, ...newLines, ...after];\n    }\n    \n    return lines.join('\\n');\n}\n\nexport function deactivate() {}\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","execAsync","promisify","exec","applyPatchToContent","originalContent","change","lines","split","sortedHunks","hunks","sort","a","b","startLine","hunk","content","hunkLines","newLines","filter","line","startsWith","map","substring","before","slice","after","length","join","context","console","log","disposable","vscode","commands","registerCommand","async","fileUris","window","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","filters","title","patchFilePath","fsPath","workspaceFolders","workspace","showErrorMessage","workspaceRoot","uri","fileChanges","patchContent","diffFiles","i","filePathMatch","match","filePath","fileType","isNew","isDeleted","j","Math","min","includes","push","inHunk","currentHunk","lineCount","hunkHeaderMatch","parseInt","parsePatchFile","fs","readFileSync","targetFilePath","path","showInformationMessage","targetFileExists","existsSync","unlinkSync","tempFilePath","basename","statSync","isDirectory","showWarningMessage","error","Error","message","String","newContent","tempDir","dirname","mkdirSync","recursive","writeFileSync","originalUri","Uri","file","with","scheme","modifiedUri","executeCommand","targetDir","subscriptions","gitApplyDisposable","cwd","stdout","changedFiles","trim","tempIndexFile","fullPath","diffOutput","env","process","GIT_INDEX_FILE"],"sourceRoot":""}